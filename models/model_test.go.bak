package models

import (
	"database/sql"
	"fmt"
	"testing"

	"github.com/rediwo/redi-orm/schema"
	"github.com/rediwo/redi-orm/types"
)

// Mock database for testing
type mockDB struct {
	data           map[string][]map[string]interface{}
	nextID         int64
	lastInsertedID int64
}

func newMockDB() *mockDB {
	return &mockDB{
		data:   make(map[string][]map[string]interface{}),
		nextID: 1,
	}
}

func (m *mockDB) Connect() error { return nil }
func (m *mockDB) Close() error   { return nil }

func (m *mockDB) CreateTable(schema interface{}) error {
	return nil
}

func (m *mockDB) DropTable(tableName string) error {
	delete(m.data, tableName)
	return nil
}

func (m *mockDB) Insert(tableName string, data map[string]interface{}) (int64, error) {
	if m.data[tableName] == nil {
		m.data[tableName] = []map[string]interface{}{}
	}

	// Add ID to data
	newData := make(map[string]interface{})
	for k, v := range data {
		newData[k] = v
	}
	newData["id"] = m.nextID

	m.data[tableName] = append(m.data[tableName], newData)
	m.lastInsertedID = m.nextID
	m.nextID++

	return m.lastInsertedID, nil
}

func (m *mockDB) FindByID(tableName string, id interface{}) (map[string]interface{}, error) {
	records, exists := m.data[tableName]
	if !exists {
		return nil, nil
	}

	for _, record := range records {
		if record["id"] == id {
			return record, nil
		}
	}

	return nil, nil
}

func (m *mockDB) Find(tableName string, conditions map[string]interface{}, limit, offset int) ([]map[string]interface{}, error) {
	records, exists := m.data[tableName]
	if !exists {
		return []map[string]interface{}{}, nil
	}

	var filtered []map[string]interface{}

	// Apply conditions
	for _, record := range records {
		match := true
		for key, value := range conditions {
			if record[key] != value {
				match = false
				break
			}
		}
		if match {
			filtered = append(filtered, record)
		}
	}

	// Apply offset and limit
	start := offset
	if start >= len(filtered) {
		return []map[string]interface{}{}, nil
	}

	end := len(filtered)
	if limit > 0 && start+limit < end {
		end = start + limit
	}

	return filtered[start:end], nil
}

func (m *mockDB) Update(tableName string, id interface{}, data map[string]interface{}) error {
	records, exists := m.data[tableName]
	if !exists {
		return nil
	}

	for i, record := range records {
		if record["id"] == id {
			for key, value := range data {
				m.data[tableName][i][key] = value
			}
			break
		}
	}

	return nil
}

func (m *mockDB) Delete(tableName string, id interface{}) error {
	records, exists := m.data[tableName]
	if !exists {
		return nil
	}

	for i, record := range records {
		if record["id"] == id {
			m.data[tableName] = append(records[:i], records[i+1:]...)
			break
		}
	}

	return nil
}

func (m *mockDB) Select(tableName string, columns []string) types.QueryBuilder {
	return &mockQueryBuilder{
		db:        m,
		tableName: tableName,
		columns:   columns,
	}
}

func (m *mockDB) Begin() (types.Transaction, error) {
	return nil, nil
}

func (m *mockDB) Exec(query string, args ...interface{}) (sql.Result, error) {
	return nil, nil
}

func (m *mockDB) Query(query string, args ...interface{}) (*sql.Rows, error) {
	return nil, nil
}

func (m *mockDB) QueryRow(query string, args ...interface{}) *sql.Row {
	return nil
}

func (m *mockDB) GetMigrator() types.DatabaseMigrator {
	return nil
}

// RegisterSchema registers a schema for model name resolution
func (m *mockDB) RegisterSchema(modelName string, schema interface{}) error {
	return nil
}

// GetRegisteredSchemas returns all registered schemas
func (m *mockDB) GetRegisteredSchemas() map[string]interface{} {
	return make(map[string]interface{})
}

// Schema-aware CRUD operations (pass through to raw operations for mock)
func (m *mockDB) Insert(modelName string, data map[string]interface{}) (int64, error) {
	return m.RawInsert(modelName, data)
}

func (m *mockDB) FindByID(modelName string, id interface{}) (map[string]interface{}, error) {
	return m.RawFindByID(modelName, id)
}

func (m *mockDB) Find(modelName string, conditions map[string]interface{}, limit, offset int) ([]map[string]interface{}, error) {
	return m.RawFind(modelName, conditions, limit, offset)
}

func (m *mockDB) Update(modelName string, id interface{}, data map[string]interface{}) error {
	return m.RawUpdate(modelName, id, data)
}

func (m *mockDB) Delete(modelName string, id interface{}) error {
	return m.RawDelete(modelName, id)
}

func (m *mockDB) Select(modelName string, columns []string) types.QueryBuilder {
	return m.RawSelect(modelName, columns)
}

// Raw operations (renamed from existing methods)
func (m *mockDB) RawInsert(tableName string, data map[string]interface{}) (int64, error) {
	if m.data[tableName] == nil {
		m.data[tableName] = []map[string]interface{}{}
	}

	// Add ID to data
	newData := make(map[string]interface{})
	for k, v := range data {
		newData[k] = v
	}
	newData["id"] = m.nextID

	m.data[tableName] = append(m.data[tableName], newData)
	m.lastInsertedID = m.nextID
	id := m.nextID
	m.nextID++

	return id, nil
}

func (m *mockDB) RawFindByID(tableName string, id interface{}) (map[string]interface{}, error) {
	records, exists := m.data[tableName]
	if !exists {
		return nil, sql.ErrNoRows
	}

	for _, record := range records {
		if record["id"] == id {
			return record, nil
		}
	}
	return nil, sql.ErrNoRows
}

func (m *mockDB) RawFind(tableName string, conditions map[string]interface{}, limit, offset int) ([]map[string]interface{}, error) {
	records, exists := m.data[tableName]
	if !exists {
		return []map[string]interface{}{}, nil
	}

	var filtered []map[string]interface{}
	for _, record := range records {
		match := true
		for k, v := range conditions {
			if record[k] != v {
				match = false
				break
			}
		}
		if match {
			filtered = append(filtered, record)
		}
	}

	// Apply offset
	if offset > 0 && offset < len(filtered) {
		filtered = filtered[offset:]
	} else if offset >= len(filtered) {
		filtered = []map[string]interface{}{}
	}

	// Apply limit
	if limit > 0 && limit < len(filtered) {
		filtered = filtered[:limit]
	}

	return filtered, nil
}

func (m *mockDB) RawUpdate(tableName string, id interface{}, data map[string]interface{}) error {
	records, exists := m.data[tableName]
	if !exists {
		return fmt.Errorf("table %s not found", tableName)
	}

	for i, record := range records {
		if record["id"] == id {
			for k, v := range data {
				records[i][k] = v
			}
			return nil
		}
	}
	return fmt.Errorf("record with id %v not found", id)
}

func (m *mockDB) RawDelete(tableName string, id interface{}) error {
	records, exists := m.data[tableName]
	if !exists {
		return fmt.Errorf("table %s not found", tableName)
	}

	for i, record := range records {
		if record["id"] == id {
			m.data[tableName] = append(records[:i], records[i+1:]...)
			return nil
		}
	}
	return fmt.Errorf("record with id %v not found", id)
}

func (m *mockDB) RawSelect(tableName string, columns []string) types.QueryBuilder {
	return &mockQueryBuilder{
		db:        m,
		tableName: tableName,
		columns:   columns,
	}
}

// Mock query builder
type mockQueryBuilder struct {
	db         *mockDB
	tableName  string
	columns    []string
	conditions map[string]interface{}
	limit      int
	offset     int
}

func (q *mockQueryBuilder) Where(field string, operator string, value interface{}) types.QueryBuilder {
	if q.conditions == nil {
		q.conditions = make(map[string]interface{})
	}
	q.conditions[field] = value
	return q
}

func (q *mockQueryBuilder) WhereIn(field string, values []interface{}) types.QueryBuilder {
	// Simplified implementation
	if len(values) > 0 {
		q.Where(field, "=", values[0])
	}
	return q
}

func (q *mockQueryBuilder) OrderBy(field string, direction string) types.QueryBuilder {
	return q
}

func (q *mockQueryBuilder) Limit(limit int) types.QueryBuilder {
	q.limit = limit
	return q
}

func (q *mockQueryBuilder) Offset(offset int) types.QueryBuilder {
	q.offset = offset
	return q
}

func (q *mockQueryBuilder) Execute() ([]map[string]interface{}, error) {
	return q.db.Find(q.tableName, q.conditions, q.limit, q.offset)
}

func (q *mockQueryBuilder) First() (map[string]interface{}, error) {
	results, err := q.db.Find(q.tableName, q.conditions, 1, q.offset)
	if err != nil {
		return nil, err
	}
	if len(results) == 0 {
		return nil, nil
	}
	return results[0], nil
}

func (q *mockQueryBuilder) Count() (int64, error) {
	results, err := q.db.Find(q.tableName, q.conditions, 0, 0)
	if err != nil {
		return 0, err
	}
	return int64(len(results)), nil
}

func createTestSchema() *schema.Schema {
	return schema.New("User").
		AddField(schema.NewField("id").Int().PrimaryKey().AutoIncrement().Build()).
		AddField(schema.NewField("name").String().Build()).
		AddField(schema.NewField("email").String().Unique().Build()).
		AddField(schema.NewField("age").Int().Nullable().Build()).
		AddField(schema.NewField("active").Bool().Default(true).Build())
}

func TestModelGet(t *testing.T) {
	db := newMockDB()
	testSchema := createTestSchema()
	model := New(testSchema, db)

	// Insert test data
	testData := map[string]interface{}{
		"name":  "John Doe",
		"email": "john@example.com",
		"age":   30,
	}
	id, _ := db.Insert("users", testData)

	// Test Get
	result, err := model.Get(id)
	if err != nil {
		t.Fatalf("Failed to get record: %v", err)
	}

	if result["name"] != "John Doe" {
		t.Errorf("Expected name 'John Doe', got '%v'", result["name"])
	}
}

func TestModelAdd(t *testing.T) {
	db := newMockDB()
	testSchema := createTestSchema()
	model := New(testSchema, db)

	// Test valid data
	testData := map[string]interface{}{
		"name":  "Jane Doe",
		"email": "jane@example.com",
		"age":   25,
	}

	id, err := model.Add(testData)
	if err != nil {
		t.Fatalf("Failed to add record: %v", err)
	}

	if id != 1 {
		t.Errorf("Expected ID 1, got %d", id)
	}

	// Verify data was added
	result, _ := model.Get(id)
	if result["name"] != "Jane Doe" {
		t.Errorf("Expected name 'Jane Doe', got '%v'", result["name"])
	}
}

func TestModelAddValidation(t *testing.T) {
	db := newMockDB()
	testSchema := createTestSchema()
	model := New(testSchema, db)

	// Test missing required field
	invalidData := map[string]interface{}{
		"age": 25,
	}

	_, err := model.Add(invalidData)
	if err == nil {
		t.Error("Expected validation error for missing required field")
	}

	// Test unknown field
	invalidData2 := map[string]interface{}{
		"name":    "John",
		"email":   "john@example.com",
		"unknown": "value",
	}

	_, err = model.Add(invalidData2)
	if err == nil {
		t.Error("Expected validation error for unknown field")
	}
}

func TestModelSet(t *testing.T) {
	db := newMockDB()
	testSchema := createTestSchema()
	model := New(testSchema, db)

	// Add initial data
	testData := map[string]interface{}{
		"name":  "Original Name",
		"email": "original@example.com",
		"age":   20,
	}
	id, _ := model.Add(testData)

	// Update data
	updateData := map[string]interface{}{
		"name": "Updated Name",
		"age":  21,
	}

	err := model.Set(id, updateData)
	if err != nil {
		t.Fatalf("Failed to update record: %v", err)
	}

	// Verify update
	result, _ := model.Get(id)
	if result["name"] != "Updated Name" {
		t.Errorf("Expected name 'Updated Name', got '%v'", result["name"])
	}
	if result["email"] != "original@example.com" {
		t.Errorf("Email should not have changed, got '%v'", result["email"])
	}
}

func TestModelRemove(t *testing.T) {
	db := newMockDB()
	testSchema := createTestSchema()
	model := New(testSchema, db)

	// Add test data
	testData := map[string]interface{}{
		"name":  "To Delete",
		"email": "delete@example.com",
		"age":   30,
	}
	id, _ := model.Add(testData)

	// Remove record
	err := model.Remove(id)
	if err != nil {
		t.Fatalf("Failed to remove record: %v", err)
	}

	// Verify removal
	result, _ := model.Get(id)
	if result != nil {
		t.Error("Expected nil result after removal")
	}
}

func TestModelSelect(t *testing.T) {
	db := newMockDB()
	testSchema := createTestSchema()
	model := New(testSchema, db)

	// Add test data
	users := []map[string]interface{}{
		{"name": "User1", "email": "user1@example.com", "age": 20},
		{"name": "User2", "email": "user2@example.com", "age": 25},
		{"name": "User3", "email": "user3@example.com", "age": 30},
	}

	for _, user := range users {
		model.Add(user)
	}

	// Test select all
	qb := model.Select()
	results, err := qb.Execute()
	if err != nil {
		t.Fatalf("Failed to execute select: %v", err)
	}
	if len(results) != 3 {
		t.Errorf("Expected 3 results, got %d", len(results))
	}

	// Test select with columns
	qb2 := model.Select("name", "email")
	results2, err := qb2.Execute()
	if err != nil {
		t.Fatalf("Failed to execute select with columns: %v", err)
	}
	if len(results2) != 3 {
		t.Errorf("Expected 3 results, got %d", len(results2))
	}

	// Test with where clause
	qb3 := model.Select().Where("age", "=", 25)
	results3, err := qb3.Execute()
	if err != nil {
		t.Fatalf("Failed to execute select with where: %v", err)
	}
	if len(results3) != 1 {
		t.Errorf("Expected 1 result, got %d", len(results3))
	}
}

func TestValidateFieldType(t *testing.T) {
	tests := []struct {
		name    string
		field   *schema.Field
		value   interface{}
		wantErr bool
	}{
		{
			name:    "Valid string",
			field:   &schema.Field{Type: schema.FieldTypeString, Nullable: false},
			value:   "test",
			wantErr: false,
		},
		{
			name:    "Invalid string type",
			field:   &schema.Field{Type: schema.FieldTypeString, Nullable: false},
			value:   123,
			wantErr: true,
		},
		{
			name:    "Null value for nullable field",
			field:   &schema.Field{Type: schema.FieldTypeString, Nullable: true},
			value:   nil,
			wantErr: false,
		},
		{
			name:    "Null value for non-nullable field",
			field:   &schema.Field{Type: schema.FieldTypeString, Nullable: false},
			value:   nil,
			wantErr: true,
		},
		{
			name:    "Valid int",
			field:   &schema.Field{Type: schema.FieldTypeInt, Nullable: false},
			value:   123,
			wantErr: false,
		},
		{
			name:    "Valid int64",
			field:   &schema.Field{Type: schema.FieldTypeInt, Nullable: false},
			value:   int64(123),
			wantErr: false,
		},
		{
			name:    "Valid float as int",
			field:   &schema.Field{Type: schema.FieldTypeInt, Nullable: false},
			value:   123.0,
			wantErr: false,
		},
		{
			name:    "Valid bool",
			field:   &schema.Field{Type: schema.FieldTypeBool, Nullable: false},
			value:   true,
			wantErr: false,
		},
		{
			name:    "Invalid bool type",
			field:   &schema.Field{Type: schema.FieldTypeBool, Nullable: false},
			value:   "true",
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := validateFieldType(tt.field, tt.value)
			if (err != nil) != tt.wantErr {
				t.Errorf("validateFieldType() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}
